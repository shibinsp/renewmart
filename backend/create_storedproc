import psycopg2
from psycopg2 import sql

def create_stored_procedures():
    try:
    
        conn = psycopg2.connect(
            host="localhost",
            database="renew",
            user="renewmart_user",
            password="Post@12345%"  # use from .env or config in production
        )
        cur = conn.cursor()

        # ---------- STORED PROCEDURES ----------

        procedures = [

            # 7.1 Create draft land (landowner)
            """
            CREATE OR REPLACE FUNCTION sp_land_create_draft(
              p_landowner UUID,
              p_title TEXT,
              p_location_text TEXT,
              p_coordinates JSONB,
              p_area NUMERIC
            ) RETURNS UUID AS $$
            DECLARE v_land UUID;
            BEGIN
              INSERT INTO lands(landowner_id,title,location_text,coordinates,area_acres,status)
              VALUES (p_landowner,p_title,p_location_text,p_coordinates,p_area,'draft')
              RETURNING land_id INTO v_land;

              INSERT INTO land_sections(land_id, section_key, assigned_role, status, data)
              SELECT v_land, sd.section_key, sd.default_role_reviewer, 'draft', '{}'::jsonb
              FROM section_definitions sd;

              RETURN v_land;
            END; $$ LANGUAGE plpgsql;
            """,

            # 7.2 Landowner submits for admin review
            """
            CREATE OR REPLACE FUNCTION sp_land_submit_for_review(
              p_land UUID,
              p_landowner UUID
            ) RETURNS VOID AS $$
            DECLARE v_owner UUID; v_status TEXT;
            BEGIN
              SELECT landowner_id, status INTO v_owner, v_status FROM lands WHERE land_id = p_land;
              IF v_owner IS NULL THEN RAISE EXCEPTION 'Land not found'; END IF;
              IF v_owner <> p_landowner THEN RAISE EXCEPTION 'Not the owner'; END IF;
              IF v_status <> 'draft' THEN RAISE EXCEPTION 'Only DRAFT can be submitted'; END IF;

              UPDATE land_sections
              SET status = 'submitted', submitted_at = now()
              WHERE land_id = p_land AND status = 'draft';

              UPDATE lands SET status='submitted' WHERE land_id = p_land;
            END; $$ LANGUAGE plpgsql;
            """,

            # 7.3 Admin assigns section to reviewer
            """
            CREATE OR REPLACE FUNCTION sp_assign_section(
              p_land_section UUID,
              p_role TEXT,
              p_user UUID
            ) RETURNS VOID AS $$
            BEGIN
              UPDATE land_sections
                 SET assigned_role = p_role,
                     assigned_user = p_user
               WHERE land_section_id = p_land_section;
            END; $$ LANGUAGE plpgsql;
            """,

            # 7.4 Admin sets project intent
            """
            CREATE OR REPLACE FUNCTION sp_admin_define_project(
              p_land UUID,
              p_energy TEXT,
              p_capacity_mw NUMERIC,
              p_price_per_mwh NUMERIC,
              p_timeline TEXT,
              p_contract_years INT,
              p_developer TEXT
            ) RETURNS VOID AS $$
            BEGIN
              UPDATE lands
                 SET energy_key = p_energy,
                     capacity_mw = p_capacity_mw,
                     price_per_mwh = p_price_per_mwh,
                     timeline_text = p_timeline,
                     contract_term_years = p_contract_years,
                     developer_name = p_developer
               WHERE land_id = p_land;
            END; $$ LANGUAGE plpgsql;
            """,

            # 7.5 Role users create/update tasks
            """
            CREATE OR REPLACE FUNCTION sp_task_create(
              p_land UUID,
              p_land_section UUID,
              p_title TEXT,
              p_desc TEXT,
              p_assigned_role TEXT,
              p_assigned_to UUID,
              p_start DATE,
              p_end DATE,
              p_created_by UUID
            ) RETURNS UUID AS $$
            DECLARE v_id UUID;
            BEGIN
              INSERT INTO tasks(land_id, land_section_id, title, description, assigned_role, assigned_to,
                                status, start_date, end_date, created_by)
              VALUES (p_land, p_land_section, p_title, p_desc, p_assigned_role, p_assigned_to,
                      'assigned', p_start, p_end, p_created_by)
              RETURNING task_id INTO v_id;
              RETURN v_id;
            END; $$ LANGUAGE plpgsql;
            """,

            """
            CREATE OR REPLACE FUNCTION sp_task_update_status(
              p_task UUID,
              p_new_status TEXT,
              p_user UUID,
              p_note TEXT DEFAULT NULL
            ) RETURNS VOID AS $$
            BEGIN
              UPDATE tasks SET status = p_new_status, updated_at = now(), created_by = p_user
              WHERE task_id = p_task;

              UPDATE task_history SET note = COALESCE(note,'') || CASE WHEN p_note IS NULL THEN '' ELSE E'\n' || p_note END
              WHERE task_id = p_task AND end_ts IS NULL;
            END; $$ LANGUAGE plpgsql;
            """,

            # 7.6 Section approval/rejection
            """
            CREATE OR REPLACE FUNCTION sp_section_decide(
              p_land_section UUID,
              p_decision TEXT,
              p_reviewer UUID,
              p_comment TEXT
            ) RETURNS VOID AS $$
            DECLARE v_land UUID;
            BEGIN
              IF p_decision NOT IN ('approved','rejected') THEN RAISE EXCEPTION 'Invalid decision'; END IF;

              UPDATE land_sections
                 SET status = p_decision,
                     reviewer_comments = p_comment,
                     approved_at = CASE WHEN p_decision='approved' THEN now() END,
                     rejected_at = CASE WHEN p_decision='rejected' THEN now() END
               WHERE land_section_id = p_land_section;

              SELECT land_id INTO v_land FROM land_sections WHERE land_section_id = p_land_section;
              IF NOT EXISTS (
                  SELECT 1 FROM land_sections WHERE land_id=v_land AND status <> 'approved'
              ) THEN
                UPDATE lands SET status='approved' WHERE land_id = v_land AND status IN ('submitted','under_review','approved');
              ELSE
                UPDATE lands SET status='under_review' WHERE land_id = v_land AND status IN ('submitted','under_review','approved');
              END IF;
            END; $$ LANGUAGE plpgsql;
            """,

            # 7.7 Publish to investors
            """
            CREATE OR REPLACE FUNCTION sp_publish_land(p_land UUID, p_admin UUID)
            RETURNS VOID AS $$
            DECLARE ok BOOLEAN;
            BEGIN
              SELECT
                (title IS NOT NULL AND location_text IS NOT NULL AND energy_key IS NOT NULL
                 AND capacity_mw IS NOT NULL AND price_per_mwh IS NOT NULL
                 AND timeline_text IS NOT NULL AND contract_term_years IS NOT NULL
                 AND developer_name IS NOT NULL)
              INTO ok
              FROM lands WHERE land_id=p_land;

              IF NOT ok THEN RAISE EXCEPTION 'Missing required fields for publish'; END IF;

              UPDATE lands
                 SET status='published', published_at=now()
               WHERE land_id=p_land AND status IN ('approved','investor_ready');

              IF NOT FOUND THEN
                RAISE EXCEPTION 'Land must be APPROVED/INVESTOR_READY before publishing';
              END IF;
            END; $$ LANGUAGE plpgsql;
            """,

            # 7.8 Investor expresses interest
            """
            CREATE OR REPLACE FUNCTION sp_investor_express_interest(
              p_land UUID,
              p_investor UUID,
              p_comments TEXT
            ) RETURNS UUID AS $$
            DECLARE v_interest UUID; v_status TEXT;
            BEGIN
              SELECT status INTO v_status FROM lands WHERE land_id=p_land;
              IF v_status <> 'published' THEN
                RAISE EXCEPTION 'Land is not open for new interests';
              END IF;

              INSERT INTO investor_interests(investor_id, land_id, comments, status)
              VALUES (p_investor, p_land, p_comments, 'submitted')
              RETURNING interest_id INTO v_interest;

              UPDATE lands SET status='interest_locked', interest_locked_at=now() WHERE land_id=p_land;

              RETURN v_interest;
            END; $$ LANGUAGE plpgsql;
            """,

            # 7.9 Move to RTB
            """
            CREATE OR REPLACE FUNCTION sp_land_mark_rtb(p_land UUID, p_admin UUID)
            RETURNS VOID AS $$
            DECLARE pending_sections INT; open_tasks INT;
            BEGIN
              SELECT count(*) INTO pending_sections
              FROM land_sections WHERE land_id=p_land AND status <> 'approved';

              IF pending_sections > 0 THEN
                RAISE EXCEPTION 'All sections must be approved before RTB';
              END IF;

              SELECT count(*) INTO open_tasks
              FROM tasks WHERE land_id=p_land AND status NOT IN ('completed','rejected','on_hold');

              IF open_tasks > 0 THEN
                RAISE EXCEPTION 'All tasks must be completed/reconciled before RTB';
              END IF;

              UPDATE lands SET status='rtb' WHERE land_id=p_land;
            END; $$ LANGUAGE plpgsql;
            """
        ]

        # ---------- EXECUTE ALL PROCEDURES ----------
        for proc in procedures:
            cur.execute(proc)
            print("✅ Procedure executed successfully")

        conn.commit()
        print("\nAll stored procedures created successfully!")

    except Exception as e:
        print("❌ Error while creating stored procedures:", e)
        conn.rollback()

    finally:
        if conn:
            cur.close()
            conn.close()

if __name__ == "__main__":
    create_stored_procedures()
